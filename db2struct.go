package db2struct

import (
	"bytes"
	"database/sql"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"log"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"

	_ "github.com/go-sql-driver/mysql"
	"github.com/urfave/cli"
)

var (
	addTag     = ""
	re         = regexp.MustCompile("[0-9A-Za-z]+")
	nullFields = []string{"bool", "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "float64", "string"}
)

type ColumnSchema struct {
	TableName              string
	ColumnName             string
	IsNullable             string
	DataType               string
	CharacterMaximumLength sql.NullInt64
	NumericPrecision       sql.NullInt64
	NumericScale           sql.NullInt64
	ColumnType             string
	ColumnKey              string
}

func (c ColumnSchema) Nullable() bool {
	return c.IsNullable == "YES"
}

func (c ColumnSchema) Unsigned() bool {
	return strings.Contains(c.ColumnType, "unsigned")
}

func Generate(c *cli.Context) error {
	var args = c.Args()
	if len(args) < 1 {
		cli.ShowAppHelp(c)
		os.Exit(1)
	}

	if c.Bool("omitempty") {
		addTag = ",omitempty"
	}

	dbstring := args[0]
	columnSchema, err := getSchema(dbstring)
	if err != nil {
		log.Fatal(err)
	}

	im := make(chan ast.Spec)
	ch := make(chan ast.Spec)
	go func() {
		newType(im, ch, columnSchema)
		close(ch)
	}()

	var types []ast.Decl

	for spec := range im {
		types = append(types, &ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{
				spec,
			},
		})
	}

	for spec := range ch {
		types = append(types, &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				spec,
			},
		})
	}

	file := &ast.File{
		Name:  ast.NewIdent(c.String("package")),
		Decls: types,
	}

	fmt.Fprintf(os.Stdout, "// automatically generated by db2struct, do not modify\n")
	printer.Fprint(os.Stdout, token.NewFileSet(), file)
	return nil
}

func newType(im chan ast.Spec, ch chan ast.Spec, columns []ColumnSchema) {
	tableNames := make([]string, 0)
	tables := make(map[string][]ColumnSchema)
	imports := make(map[string]interface{})

	for _, c := range columns {
		tableName := c.TableName
		if strings.HasPrefix(tableName, "goose") {
			continue
		}
		val, ok := tables[tableName]
		if !ok {
			val = []ColumnSchema{}
			tableNames = append(tableNames, tableName)
		}
		val = append(val, c)
		tables[tableName] = val
		_, p := db2goType(c)
		if p != "" {
			imports[p] = struct{}{}
		}
	}

	for p := range imports {
		spec := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: strconv.Quote(p),
			},
		}
		im <- spec
	}
	close(im)

	for _, name := range nullFields {
		nullType(ch, name)
	}

	sort.Strings(tableNames)
	for _, tableName := range tableNames {
		fieldColumns := tables[tableName]

		fields := make([]*ast.Field, len(fieldColumns))

		for i, c := range fieldColumns {
			k := c.ColumnName
			ts, _ := db2goType(c)

			fields[i] = &ast.Field{
				Names: []*ast.Ident{
					&ast.Ident{
						Name:    pascalCase(k),
						NamePos: token.NoPos,
						Obj:     ast.NewObj(ast.Var, k),
					},
				},
				Type: ast.NewIdent(ts),
				Tag: &ast.BasicLit{
					ValuePos: token.NoPos,
					Kind:     token.STRING,
					Value:    fmt.Sprintf("`db:\"%s%s\"`", k, addTag),
				},
			}
		}
		spec := &ast.TypeSpec{
			Name: ast.NewIdent(pascalCase(tableName)),
			Type: &ast.StructType{
				Fields: &ast.FieldList{
					List: fields,
				},
			},
		}
		ch <- spec
	}

}

func nullType(ch chan ast.Spec, ts string) {
	name := pascalCase("null_" + ts)
	fname := pascalCase(ts)
	fields := make([]*ast.Field, 2)

	createField := func(name, ts string) *ast.Field {
		return &ast.Field{
			Names: []*ast.Ident{
				&ast.Ident{
					Name:    name,
					NamePos: token.NoPos,
					Obj:     ast.NewObj(ast.Var, name),
				},
			},
			Type: ast.NewIdent(ts),
		}
	}

	fields[0] = createField(fname, ts)
	fields[1] = createField("Valid", "bool")

	spec := &ast.TypeSpec{
		Name: ast.NewIdent(name),
		Type: &ast.StructType{
			Fields: &ast.FieldList{
				List: fields,
			},
		},
	}
	ch <- spec
}

func db2goType(c ColumnSchema) (string, string) {
	t, p := "", ""
	nullable := c.Nullable()

	switch c.DataType {
	case "char":
		fallthrough
	case "varchar", "enum", "text", "longtext", "mediumtext", "tinytext":
		if nullable {
			t = "NullString"
		} else {
			t = "string"
		}
	case "blob", "mediumblob", "longblob", "varbinary", "binary":
		t = "[]byte"
	case "date", "time", "datetime", "timestamp":
		t, p = "time.Time", "time"
	case "tinyint":
		t = numericType(c, 8)
	case "smallint":
		t = numericType(c, 16)
	case "int", "mediumint":
		t = numericType(c, 32)
	case "bigint":
		t = numericType(c, 64)
	case "float", "decimal", "double":
		if nullable {
			t = "NullFloat64"
		} else {
			t = "float64"
		}
	case "bit":
		t = "byte"
	}
	return t, p
}

func numericType(c ColumnSchema, num int) (t string) {
	unsigned := c.Unsigned()
	nullable := c.Nullable()

	if unsigned && nullable {
		t = fmt.Sprintf("NullUInt%d", num)
	} else if unsigned && !nullable {
		t = fmt.Sprintf("uint%d", num)
	} else if !unsigned && nullable {
		t = fmt.Sprintf("NullInt%d", num)
	} else {
		t = fmt.Sprintf("int%d", num)
	}
	return
}

func getSchema(dbstring string) ([]ColumnSchema, error) {
	conn, err := sql.Open("mysql", dbstring)
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	// TODO:
	attr := strings.Split(dbstring, "/")

	q := "SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, DATA_TYPE, " +
		"CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, COLUMN_TYPE, " +
		"COLUMN_KEY FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = ? ORDER BY TABLE_NAME, ORDINAL_POSITION"

	rows, err := conn.Query(q, attr[1])
	if err != nil {
		return nil, err
	}

	columns := []ColumnSchema{}
	for rows.Next() {
		s := ColumnSchema{}
		err := rows.Scan(&s.TableName, &s.ColumnName, &s.IsNullable,
			&s.DataType, &s.CharacterMaximumLength,
			&s.NumericPrecision, &s.NumericScale,
			&s.ColumnType, &s.ColumnKey)
		if err != nil {
			return nil, err
		}
		columns = append(columns, s)
	}

	return columns, nil
}

func pascalCase(s string) string {
	b := []byte(s)
	values := re.FindAll(b, -1)
	for i, v := range values {
		values[i] = bytes.Title(v)
	}
	return string(bytes.Join(values, nil))
}
